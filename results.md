CS 225 Final Project - Open Flights Dataset

By: Meghna Pillai, Anna Liu, Zhaoqi Xia

Our leading question is to use the information from the OpenFlights dataset to compute the distance and find the shortest path between two cities. We achieved this goal by first creating parsing and data storing abilities for the airport data and routes data from the dataset. Following, we are able to traverse through the graph and visit nodes using BFS and then use Dijkstra's algorithm to find the shortest path given two airports. For example, with our project, we found that the distance for the shortest path from Auckland, New Zealand to MÃ¡laga, Spain is 19968 km and the distance from Chicago to Bangalore, India is 13731 km.

To complete this project, our team first fetched the necessary data from OpenFlights, which included information about airports and routes. The data was in CSV format, with each line representing a single airport or route. We parsed each line to ensure we did not use any invalid lines. We then converted the data into a vector of strings to construct airport objects. Each airport object includes an unordered map to store information about adjacent airports and their paths. When inserting edges, we calculated the weight of the edge based on the coordinates of the two airports. The airports are the vertices, and the routes are the edges, with the weight as the distance. We only inserted any paths that were repeated once to keep the graph simple. We created a graph class to insert vertices, create and insert edges, and fetch information about vertices, adjacent vertices, their data, and the weight between them.

To find the shortest flight from a user's starting airport to their destination airport, we used Breadth First Search in conjunction with Dijkstra's Algorithm. Dijkstra's algorithm calculates the shortest path between two points using the weights of the edges that connect them. Our algorithm uses a map with airport IDs as keys and distances of every other vertex from the source as values. It also contains another map that stores the required flight path relative to the current vertex and a map keeping track of visited vertices. By keeping track of these "edges" in a priority queue, we localized a path that would take the least time to reach the user's destination.

Our team implemented a Page Rank algorithm to evaluate the importance of various airports. The algorithm produces two vectors: one with the airport IDs and the other with the significance value of each airport. The algorithm first extracts the adjacency matrix from the graph. Then, it stores the weights of each airport's flights in the adjacency matrix. The matrix is then adjusted to satisfy the requirements of the Page Rank algorithm. We then generate a starting vector with random numbers and calculate the product of the matrix and the starting vector to produce a result vector revealing the future state of the airport. By recursing through this process, we get to a stable state where we can rank the importance of the airports. We tested the implementation by constructing a simple graph and comparing the result to our intuition, which concluded that the algorithm met our expecations.

Toward the middle of our project, we struggled with organizing our code because we did not spend enough time designing the structure at the beginning. Therefore, if we were to do this again, we would spend a lot more time planning where everything is supposed to go before starting to code to save time and frustration. Furthermore, if we were provided with more time to work on the project, we would expand it by finding a way to visually represent the graph data to ensure that the shortest path of each airport from another can easily be found and compared with each other.
